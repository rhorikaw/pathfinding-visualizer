<!doctype html><html lang="en"><head><meta charset="utf-8"/><link rel="stylesheet" href="style.css"/><link rel="icon" href="/pathfinding-visualizer/favicon.ico"/><meta name="viewport" content="width=device-width,initial-scale=1"/><meta name="theme-color" content="#000000"/><meta name="description" content="Web site created using create-react-app"/><link rel="apple-touch-icon" href="/pathfinding-visualizer/logo192.png"/><link rel="manifest" href="/pathfinding-visualizer/manifest.json"/><title>Pathfinding Algorithm: Visualizer</title><script>const openModal=e=>{document.getElementById(e).style.display="block"},closeModal=e=>{document.getElementById(e).style.display="none"},transitionModal=(e,t)=>{const l=document.getElementById(e),n=document.getElementById(t);l.style.display="none",n.style.display="block"}</script><link href="/pathfinding-visualizer/static/css/main.ba732e59.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="container"><div id="header"><h1>Pathfinding Visualizer<help style="float:right;padding-right:3px"><svg width="0.75em" height="0.75em" onclick='openModal("helpModal")' viewBox="0 0 16 16" class="bi bi-question-circle-fill" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM6.57 6.033H5.25C5.22 4.147 6.68 3.5 8.006 3.5c1.397 0 2.673.73 2.673 2.24 0 1.08-.635 1.594-1.244 2.057-.737.559-1.01.768-1.01 1.486v.355H7.117l-.007-.463c-.038-.927.495-1.498 1.168-1.987.59-.444.965-.736.965-1.371 0-.825-.628-1.168-1.314-1.168-.901 0-1.358.603-1.358 1.384zm1.251 6.443c-.584 0-1.009-.394-1.009-.927 0-.552.425-.94 1.01-.94.609 0 1.028.388 1.028.94 0 .533-.42.927-1.029.927z"/></svg></help></h1></div><div id="helpModal" class="modal"><div class="modal-content"><span class="close" onclick='closeModal("helpModal")'>&times;</span><h2>Welcome to the Pathfinding Visualizer!</h2><img src="https://bodyulcg.com/wp-content/uploads/path-finding-visualizer.jpg" alt="pathfinding" style="display:block;margin-left:auto;margin-right:auto" width="385" height="222"><h3>What is a pathfinding algorithm?</h3><h4>Essentially, a pathfinding algorithm attempts to find the "shortest" path, or the path with the lowest cost between two nodes on a graph. These algorithms play a vital part in modern technology, as they are integrated in common applications such as online map services and satellite navigation systems. Read more about pathfinding algorithms and graphs <a href="https://medium.com/swlh/pathfinding-algorithms-6c0d4febe8fd" target="_blank">here</a>.</h4><h4>This application was made to demonstrate how each algorithm works and performs. As a disclaimer, the cost of moving from one node to the next is one, and algorithms will prioritize a straight path over a path with many turns if it has the same cost. Take a look at all of the available algorithms in the next slide.</h4><nextbutton onclick='transitionModal("helpModal","algorithmModal")'>Next</nextbutton></div></div><div id="algorithmModal" class="modal"><div class="modal-content"><span class="close" onclick='closeModal("algorithmModal")'>&times;</span><h2>The Pathfinding Algorithms and Heuristics</h2><h3>A quick description of each algorithm</h3><p><b>Dijkstra's Algorithm:</b> One of the most popular pathfinding algorithms. It considers weights of each visited node and guarantees the shortest path.</p><p><b>A* Pathfinding Algorithm:</b> This is the best pathfinding algorithm that utilizes the cost of the path so far <em>g(n)</em>{" "} and the estimate from the heuristic function <em>h(n)</em>. It considers weights of each visited node and dguarantees the shortest path.</p><p><b>Greedy Best First Search:</b> This algorithm utilizes a heuristic function <em>h(n)</em> to determine the next node to explore. It considers thee weights of each visited node but it does not guarantee an optimal solution.</p><p><b>Breadth First Search:</b> This algorithm searches all of the nodes in the same depth before proceeding to the next depth level. This algorithm does <b>NOT</b> consider the weights of nodes, but will guarantee the shortest path.</p><p><b>Bidirectional Breadth First Search:</b> This algorithm is essentially the same as breadth first search. However, instead of beginning the search at the start node, it begins the search at both the start <b>and</b> finish nodes.</p><p><b>Depth First Search:</b> This algorithm is one of the worst pathfinding algorithms. It attempts to visit the "deepest" nodes first and backtracks once no other nodes can be visited. This algorithm does <b>NOT</b> consider the weights of the nodes and it does <b>NOT</b> guarantee the shortest path.</p><h3>A quick description of each heuristic</h3><p><b>Manhattan Distance:</b> Uses the formula, d = |x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>| to give an estimate cost.</p><p><b>Euclidean Distance</b> Uses the formula, d = <span>&#8730; <span style="border-top:solid 1px #000;display:inline-block;line-height:12.5px">(x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y <sub>1</sub> - y<sub>2</sub>)<sup>2</sup> </span></span>to give an estimate cost.</p><prevbutton onclick='transitionModal("algorithmModal","helpModal")'>Previous</prevbutton><nextbutton onclick='transitionModal("algorithmModal","obstacleModal")'>Next</nextbutton></div></div><div id="obstacleModal" class="modal"><div class="modal-content"><span class="close" onclick='closeModal("obstacleModal")'>&times;</span><h2>Modifying the Grid</h2><h4>Besides changing the algorithms and heuristics, it is also possible to add obstacles to the grid. Obstacles will effectively increase the cost of the node and may cause the algorithm to take a different path. To add obstacles, simply select one on the navbar and left-click on the desired node, or left-click and drag the mouse across the desired nodes. For reference;</h4><h4><b>Blank nodes</b> have a cost of 1</h4><h4><b>Goblins</b> have a cost of 2</h4><h4><b>Ogres</b> have a cost of 5</h4><h4><b>Witches</b> have a cost of 10</h4><h4><b>Bears</b> have a cost of 15</h4><h4><b>Dragons</b> have a cost of 25</h4><h4 style="margin-bottom:62px">On top of manually adding obstacles, there are a few mazes and patterns that can be automatically generated. To add one to the grid, simply select one from the menu bar and it will be generated promptly. If needed, the simulation speed can also be modified in a similar fashion. Lastly, it is possible to change the location of the start and end nodes. To do so, simply click, hold, and drag the terminal nodes to the desired location.</h4><prevbutton onclick='transitionModal("obstacleModal","algorithmModal")'>Previous</prevbutton><nextbutton onclick='transitionModal("obstacleModal","finalModal")'>Next</nextbutton></div></div><div id="finalModal" class="modal"><div class="modal-content"><span class="close" onclick='closeModal("finalModal")'>&times;</span><h2 style="margin-top:150px">That's All Folks!</h2><h3>This concludes the tutorial for my pathfinding visualizer.</h3><h3 style="font-size:1.2em">Have fun playing around with all of the different algorithms!</h3><p style="text-align:center;margin-bottom:212px">The source code for this visualizer can be found on my <a href="https://github.com/rhorikaw/pathfinding-visualizer" target="_blank">github</a>.</p><prevbutton onclick='transitionModal("finalModal","obstacleModal")'>Previous</prevbutton><nextbutton onclick='closeModal("finalModal")'>Close</nextbutton></div></div><div id="content"><div id="root"></div></div></div><script>!function(e){function r(r){for(var n,u,a=r[0],l=r[1],f=r[2],c=0,s=[];c<a.length;c++)u=a[c],Object.prototype.hasOwnProperty.call(o,u)&&o[u]&&s.push(o[u][0]),o[u]=0;for(n in l)Object.prototype.hasOwnProperty.call(l,n)&&(e[n]=l[n]);for(p&&p(r);s.length;)s.shift()();return i.push.apply(i,f||[]),t()}function t(){for(var e,r=0;r<i.length;r++){for(var t=i[r],n=!0,a=1;a<t.length;a++){var l=t[a];0!==o[l]&&(n=!1)}n&&(i.splice(r--,1),e=u(u.s=t[0]))}return e}var n={},o={1:0},i=[];function u(r){if(n[r])return n[r].exports;var t=n[r]={i:r,l:!1,exports:{}};return e[r].call(t.exports,t,t.exports,u),t.l=!0,t.exports}u.m=e,u.c=n,u.d=function(e,r,t){u.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},u.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},u.t=function(e,r){if(1&r&&(e=u(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(u.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)u.d(t,n,function(r){return e[r]}.bind(null,n));return t},u.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return u.d(r,"a",r),r},u.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},u.p="/pathfinding-visualizer/";var a=this["webpackJsonppathfinding-visualizer"]=this["webpackJsonppathfinding-visualizer"]||[],l=a.push.bind(a);a.push=r,a=a.slice();for(var f=0;f<a.length;f++)r(a[f]);var p=l;t()}([])</script><script src="/pathfinding-visualizer/static/js/2.97d5f3a7.chunk.js"></script><script src="/pathfinding-visualizer/static/js/main.697ec38c.chunk.js"></script></body><footer></footer></html>