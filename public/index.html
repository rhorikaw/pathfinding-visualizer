<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="Web site created using create-react-app" />
  <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
  <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
  <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
  <title>Pathfinding Algorithm: Visualizer</title>
  <script>
    const openModal = (elementId) => {
      const modal = document.getElementById(elementId);
      modal.style.display = "block";
    };

    const closeModal = (elementId) => {
      const modal = document.getElementById(elementId);
      modal.style.display = "none";
    };

    const transitionModal = (previousElementId, newElementId) => {
      const previousModal = document.getElementById(previousElementId);
      const newModal = document.getElementById(newElementId);
      previousModal.style.display = "none";
      newModal.style.display = "block";
    };
  </script>
</head>

<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="container">
    <div id="header">
      <h1>
        Pathfinding Visualizer
        <help style="float: right; padding-right: 3px;">
          <svg width="0.75em" height="0.75em" onclick="openModal('helpModal')" viewBox="0 0 16 16"
            class="bi bi-question-circle-fill" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd"
              d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM6.57 6.033H5.25C5.22 4.147 6.68 3.5 8.006 3.5c1.397 0 2.673.73 2.673 2.24 0 1.08-.635 1.594-1.244 2.057-.737.559-1.01.768-1.01 1.486v.355H7.117l-.007-.463c-.038-.927.495-1.498 1.168-1.987.59-.444.965-.736.965-1.371 0-.825-.628-1.168-1.314-1.168-.901 0-1.358.603-1.358 1.384zm1.251 6.443c-.584 0-1.009-.394-1.009-.927 0-.552.425-.94 1.01-.94.609 0 1.028.388 1.028.94 0 .533-.42.927-1.029.927z" />
          </svg>
        </help>
      </h1>
    </div>
    <div id="helpModal" class="modal">
      <div class="modal-content">
        <span class="close" onClick="closeModal('helpModal')">
          &times;
        </span>
        <h2>Welcome to the Pathfinding Visualizer!</h2>
        <img src="https://bodyulcg.com/wp-content/uploads/path-finding-visualizer.jpg" alt="pathfinding"
          style="display: block; margin-left: auto; margin-right: auto;" width="385" height="222"></img>
        <h3>What is a pathfinding algorithm?</h3>
        <h4>
          Essentially, a pathfinding algorithm attempts to find the
          "shortest" path, or the path with the lowest cost between two
          nodes on a graph. These algorithms play a vital part in modern
          technology, as they are integrated in common applications such as
          online map services and satellite navigation systems. Read more
          about pathfinding algorithms and graphs
          <a href="https://medium.com/swlh/pathfinding-algorithms-6c0d4febe8fd" target="_blank">here</a>.
        </h4>
        <h4>
          This application was made to demonstrate how each algorithm works
          and performs. As a disclaimer, the cost of moving from one node to
          the next is one, and algorithms will prioritize a straight path
          over a path with many turns if it has the same cost. Take a look
          at all of the available algorithms in the next slide.
        </h4>
        <nextbutton onClick="transitionModal('helpModal', 'algorithmModal')">Next</nextbutton>
      </div>
    </div>
    <div id="algorithmModal" class="modal">
      <div class="modal-content">
        <span class="close" onClick="closeModal('algorithmModal')">
          &times;
        </span>
        <h2>The Pathfinding Algorithms and Heuristics</h2>
        <h3>A quick description of each algorithm</h3>
        <p>
          <b>Dijkstra's Algorithm:</b> One of the most popular pathfinding
          algorithms. It considers weights of each visited node and
          guarantees the shortest path.
        </p>
        <p>
          <b>A* Pathfinding Algorithm:</b> This is the best pathfinding
          algorithm that utilizes the cost of the path so far <em>g(n)</em>{" "}
          and the estimate from the heuristic function <em>h(n)</em>. It
          considers weights of each visited node and dguarantees the
          shortest path.
        </p>
        <p>
          <b>Greedy Best First Search:</b> This algorithm utilizes a
          heuristic function <em>h(n)</em> to determine the next node to
          explore. It considers thee weights of each visited node but it
          does not guarantee an optimal solution.
        </p>
        <p>
          <b>Breadth First Search:</b> This algorithm searches all of the
          nodes in the same depth before proceeding to the next depth level.
          This algorithm does <b>NOT</b> consider the weights of nodes, but
          will guarantee the shortest path.
        </p>
        <p>
          <b>Bidirectional Breadth First Search:</b> This algorithm is
          essentially the same as breadth first search. However, instead of
          beginning the search at the start node, it begins the search at
          both the start <b>and</b> finish nodes.
        </p>
        <p>
          <b>Depth First Search:</b> This algorithm is one of the worst
          pathfinding algorithms. It attempts to visit the "deepest" nodes
          first and backtracks once no other nodes can be visited. This
          algorithm does <b>NOT</b> consider the weights of the nodes and it
          does <b>NOT</b> guarantee the shortest path.
        </p>
        <h3>A quick description of each heuristic</h3>
        <p>
          <b>Manhattan Distance:</b> Uses the formula, d = |x<sub>1</sub> -
          x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>| to give an
          estimate cost.
        </p>
        <p>
          <b>Euclidean Distance</b> Uses the formula, d =
          <span>
            &#8730;
            <span style="
                  border-top: solid 1px black;
                  display: inline-block;
                  line-height: 12.5px
                ">
              (x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y
              <sub>1</sub> - y<sub>2</sub>)<sup>2</sup>
            </span>
          </span>
          to give an estimate cost.
        </p>
        <prevbutton onClick="transitionModal('algorithmModal', 'helpModal')">
          Previous
        </prevbutton>
        <nextbutton onClick="transitionModal('algorithmModal', 'obstacleModal')">
          Next
        </nextbutton>
      </div>
    </div>
    <div id="obstacleModal" class="modal">
      <div class="modal-content">
        <span class="close" onClick="closeModal('obstacleModal')">
          &times;
        </span>
        <h2>Modifying the Grid</h2>
        <h4>
          Besides changing the algorithms and heuristics, it is also
          possible to add obstacles to the grid. Obstacles will effectively
          increase the cost of the node and may cause the algorithm to take
          a different path. To add obstacles, simply select one on the
          navbar and left-click on the desired node, or left-click and drag
          the mouse across the desired nodes. For reference;
        </h4>
        <h4>
          <b>Blank nodes</b> have a cost of 1
        </h4>
        <h4>
          <b>Goblins</b> have a cost of 2
        </h4>
        <h4>
          <b>Ogres</b> have a cost of 5
        </h4>
        <h4>
          <b>Witches</b> have a cost of 10
        </h4>
        <h4>
          <b>Bears</b> have a cost of 15
        </h4>
        <h4>
          <b>Dragons</b> have a cost of 25
        </h4>
        <h4 style="margin-bottom: 62px">
          On top of manually adding obstacles, there are a few mazes and
          patterns that can be automatically generated. To add one to the
          grid, simply select one from the menu bar and it will be generated
          promptly. If needed, the simulation speed can also be modified in
          a similar fashion.
          Lastly, it is possible to change the location of the start and end
          nodes. To do so, simply click, hold, and drag the terminal nodes
          to the desired location.
        </h4>
        <prevbutton onClick="transitionModal('obstacleModal', 'algorithmModal')">
          Previous
        </prevbutton>
        <nextbutton onclick="transitionModal('obstacleModal', 'finalModal')">Next</nextbutton>
      </div>
    </div>
    <div id="finalModal" class="modal">
      <div class="modal-content">
        <span class="close" onClick="closeModal('finalModal')">
          &times;
        </span>
        <h2 style="margin-top: 150px">That's All Folks!</h2>
        <h3>
          This concludes the tutorial for my pathfinding visualizer.
        </h3>
        <h3 style="font-size: 1.2em"> Have fun playing around with all of the different algorithms!
        </h3>
        <p style="text-align: center; margin-bottom: 212px">The source code for this visualizer can be found on my <a
            href="https://github.com/rhorikaw/pathfinding-visualizer" target="_blank">github</a>.</p>
        <prevbutton onClick="transitionModal('finalModal', 'obstacleModal')">
          Previous
        </prevbutton>
        <nextbutton onclick="closeModal('finalModal')">Close</nextbutton>
      </div>
    </div>
    <div id="content">
      <div id="root"></div>
    </div>
  </div>
</body>
<footer></footer>

</html>