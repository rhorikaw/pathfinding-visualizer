{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","data structures/minheap.js","algorithms/dijkstra.js","heuristics.js","algorithms/a-star.js","algorithms/depth-first.js","algorithms/best-first.js","algorithms/breadth-first.js","algorithms/bidirectionalBFS.js","mazeGenerator.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["Node","this","props","row","col","isFinish","isStart","isVisited","isWall","obstacleType","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","MinHeap","finish","heuristic","heap","length","index","parent","Math","floor","leftChild","rightChild","parentVal","indexVal","temp","getParent","distance","tieBreak","heuristicVal","siftUp","leftVal","rightVal","smallerChild","smallerVal","n","left","getLeftChild","right","getRightChild","siftDown","element","last","push","splice","min","deleteNode","i","dijkstra","grid","start","visitedNodesInOrder","unvisitedNodesHeap","nodeHeap","node","insert","getNodeHeap","closestNodes","shortestDistance","getMin","Infinity","extractMin","sort","a","b","updateNeighbors","heapify","neighbors","getNeighbors","neighbor","weight","directionChangeCheck","previousNode","tempNeighborDistance","tempNeighborDirection","direction","tempNeighborTieBreak","previousDist","lineDistance","manhattan","abs","euclidian","sqrt","aStar","getHeuristicVal","directionChange","closestNode","console","log","updateNeighbor","unshift","greedyBFS","filter","breadthFirst","bidirectionalBFS","neighborsFromStart","neighborsFromFinish","pathFoundStart","pathFoundFinish","nodes","getNodeList","visitedStartNodes","visitedFinishNodes","updateData","pathFound","nextStartNeighbors","nextFinishNeighbors","neighborListLength","sortNodes","includes","mergePoint","shortestPath","getShortestPath","every","val","removeDuplicates","unvisitedNodes","list","value","indexOf","origin","pathIsFound","isFromStart","nodesInShortestPathOrder","toStart","toFinish","generateRecursiveMaze","recursiveMazeHelper","minRowNum","minColNum","maxRowNum","maxColNum","prevGapNeighbors","possibleWallIndices","possibleGapIndices","gapNeighbors","checkColWall","j","randomWallIndex","random","randomGapIndex","concat","r","isNotTerminalNode","checkRowWall","c","minRow","maxRow","minCol","maxCol","weightDictionary","goblin","ogre","witch","bear","dragon","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","state","boardIsCleared","mouseIsPressed","wallSelected","pressedStart","pressedFinish","algorithm","obstacle","speed","visitedNodes","totalCost","algorithmName","newGrid","slice","document","getElementById","disabled","resetGrid","disableListElementButton","enableListElementButton","setState","heuristicName","obstacleName","speedVal","nodeNum","costVal","getInitialGrid","getNewGridWithWallToggled","getNewGridWithObstacleToggled","updateStartNode","updateFinishNode","clearGrid","newMazeGrid","parseFloat","setTimeout","enableButton","enableMazeButtons","setVisitedNodes","setCost","animateShortestPath","visitedLength","visitedFromStart","visitedFromFinish","nodeFromStart","nodeFromFinish","algorithmID","heuristicID","disableButton","disableMazeButtons","alert","startNode","finishNode","nodesToVisit","reverse","shift","nodesToQueue","depthFirst","animateBidirectional","currentNode","getNodesInShortestPathOrder","animateAlgorithm","name","content","rel","href","src","style","marginLeft","data-toggle","getAlgorithmButtonContent","onClick","setAlgorithm","getHeuristicButtonContent","setHeuristic","onMouseOver","mouseListElementHover","onMouseLeave","mouseListElementLeave","getObstacleButtonContent","setObstacle","updateGrid","prevGapCols","gapCols","wallCols","randomWallCol","generateSimpleMaze","offset","generateVShapeMaze","generateRandomMaze","getSpeedButtonContent","setSpeed","float","marginRight","clearBoard","mouseHover","mouseLeave","resetBoard","visualizeAlgorithm","getVisualizeButtonContent","padding","margin","getAnalyticsContent","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","oldStartNode","newNode","newStartNode","oldFinishNode","newFinishNode","currentRow","createNode","resetNode","hardReset","elementId","button","cursor","backgroundColor","obstacleID","numVisited","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.697ec38c.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isVisited,\r\n      isWall,\r\n      obstacleType,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n    } = this.props;\r\n\r\n    var extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    if (isVisited) {\r\n      if (obstacleType !== null) {\r\n        extraClassName = `node-${obstacleType}-visited`;\r\n      } else {\r\n        extraClassName = \"node-visited\";\r\n      }\r\n    } else {\r\n      if (obstacleType !== null) {\r\n        extraClassName = `node-${obstacleType}`;\r\n      }\r\n    }\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","export class MinHeap {\r\n  constructor(finish = null, heuristic = null) {\r\n    this.heap = [];\r\n    this.length = 0;\r\n    this.finish = finish;\r\n    this.heuristic = heuristic;\r\n  }\r\n\r\n  getMin() {\r\n    return this.heap[0];\r\n  }\r\n\r\n  getParent(index) {\r\n    var parent = Math.floor((index - 1) / 2);\r\n    if (parent < 0) {\r\n      return -1;\r\n    }\r\n    return parent;\r\n  }\r\n\r\n  getLeftChild(index) {\r\n    var leftChild = 2 * index + 1;\r\n    if (leftChild > this.length) {\r\n      return -1;\r\n    }\r\n    return leftChild;\r\n  }\r\n\r\n  getRightChild(index) {\r\n    var rightChild = 2 * index + 2;\r\n    if (rightChild > this.length) {\r\n      return -1;\r\n    }\r\n    return rightChild;\r\n  }\r\n\r\n  siftUp(index) {\r\n    var parent = this.getParent(index);\r\n    if (parent < 0) {\r\n      return;\r\n    }\r\n    var parentVal, indexVal, temp;\r\n    if (this.heuristic === null) {\r\n      parentVal = this.heap[parent].distance + this.heap[parent].tieBreak;\r\n      indexVal = this.heap[index].distance + this.heap[index].tieBreak;\r\n    } else {\r\n      parentVal = this.heap[parent].heuristicVal + this.heap[parent].tieBreak;\r\n      indexVal = this.heap[index].heuristicVal + this.heap[index].tieBreak;\r\n    }\r\n\r\n    if (index > 0 && parentVal === indexVal) {\r\n      if (this.heap[parent].distance > this.heap[index].distance) {\r\n        temp = this.heap[index];\r\n        this.heap[index] = this.heap[parent];\r\n        this.heap[parent] = temp;\r\n        this.siftUp(parent);\r\n      }\r\n    } else if (index > 0 && parentVal > indexVal) {\r\n      temp = this.heap[index];\r\n      this.heap[index] = this.heap[parent];\r\n      this.heap[parent] = temp;\r\n      this.siftUp(parent);\r\n    }\r\n  }\r\n\r\n  siftDown(index) {\r\n    var n = this.length;\r\n    var left = this.getLeftChild(index);\r\n    var right = this.getRightChild(index);\r\n\r\n    if (left <= 0 || left >= n || right <= 0 || right >= n) {\r\n      return;\r\n    }\r\n    var leftVal, rightVal, indexVal, smallerChild, smallerVal, temp;\r\n\r\n    if (this.heuristic === null) {\r\n      leftVal = this.heap[left].distance + this.heap[left].tieBreak;\r\n      rightVal = this.heap[right].distance + this.heap[right].tieBreak;\r\n      indexVal = this.heap[index].distance + this.heap[index].tieBreak;\r\n    } else {\r\n      leftVal = this.heap[left].heuristicVal + this.heap[left].tieBreak;\r\n      rightVal = this.heap[right].heuristicVal + this.heap[right].tieBreak;\r\n      indexVal = this.heap[index].heuristicVal + this.heap[index].tieBreak;\r\n    }\r\n    if (this.heuristic !== null && rightVal === leftVal) {\r\n      if (this.heap[left].distance > this.heap[right].distance) {\r\n        smallerChild = left;\r\n        smallerVal = leftVal;\r\n      } else {\r\n        smallerChild = right;\r\n        smallerVal = rightVal;\r\n      }\r\n    } else if (right < n && rightVal < leftVal) {\r\n      smallerChild = right;\r\n      smallerVal = rightVal;\r\n    } else {\r\n      smallerChild = left;\r\n      smallerVal = leftVal;\r\n    }\r\n\r\n    if (smallerChild < n && indexVal === smallerVal) {\r\n      if (this.heap[index].distance < this.heap[smallerChild].distance) {\r\n        temp = this.heap[index];\r\n        this.heap[index] = this.heap[smallerChild];\r\n        this.heap[smallerChild] = temp;\r\n        this.siftDown(smallerChild);\r\n      }\r\n    } else if (smallerChild < n && indexVal > smallerVal) {\r\n      temp = this.heap[index];\r\n      this.heap[index] = this.heap[smallerChild];\r\n      this.heap[smallerChild] = temp;\r\n      this.siftDown(smallerChild);\r\n    }\r\n  }\r\n\r\n  insert(element) {\r\n    var last = this.length;\r\n    this.length += 1;\r\n    this.heap.push(element);\r\n    this.siftUp(last);\r\n  }\r\n\r\n  deleteNode(index) {\r\n    var last = this.length - 1;\r\n    this.heap[index] = this.heap[last];\r\n    this.heap.splice(last, 1);\r\n    this.length -= 1;\r\n    this.siftUp(index);\r\n    this.siftDown(index);\r\n  }\r\n\r\n  extractMin() {\r\n    var min = this.heap[0];\r\n    this.deleteNode(0);\r\n    return min;\r\n  }\r\n\r\n  heapify() {\r\n    for (let i = this.length - 1; i >= 0; i--) {\r\n      this.siftDown(i);\r\n    }\r\n  }\r\n}\r\n","import { MinHeap } from \"../data structures/minheap\";\r\n\r\nexport function dijkstra(grid, start, finish) {\r\n  const visitedNodesInOrder = [];\r\n  start.distance = 0;\r\n\r\n  const unvisitedNodesHeap = getNodeHeap(grid);\r\n\r\n  while (unvisitedNodesHeap.length > 0) {\r\n    const closestNodes = [];\r\n    const shortestDistance = unvisitedNodesHeap.getMin().distance;\r\n    while (\r\n      unvisitedNodesHeap.length !== 0 &&\r\n      unvisitedNodesHeap.getMin().distance === shortestDistance\r\n    ) {\r\n      if (unvisitedNodesHeap.getMin().distance !== Infinity) {\r\n        closestNodes.push(unvisitedNodesHeap.extractMin());\r\n      } else {\r\n        return visitedNodesInOrder;\r\n      }\r\n    }\r\n    sortNodes(closestNodes);\r\n    if (closestNodes.length === 0) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    for (const node of closestNodes) {\r\n      if (node.isWall) {\r\n        continue;\r\n      }\r\n      if (node === finish) {\r\n        visitedNodesInOrder.push(node);\r\n        return visitedNodesInOrder;\r\n      }\r\n      visitedNodesInOrder.push(node);\r\n      updateNeighbors(start, node, grid);\r\n      unvisitedNodesHeap.heapify();\r\n    }\r\n    unvisitedNodesHeap.heapify();\r\n  }\r\n}\r\n\r\n//Implement as min-heap instead of array?\r\nfunction sortNodes(unvisitedNodes) {\r\n  unvisitedNodes.sort((a, b) => a.row - b.row);\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  if (row < grid.length - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  if (col < grid[0].length - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  return neighbors;\r\n}\r\n\r\nfunction updateNeighbors(start, node, grid) {\r\n  const neighbors = getNeighbors(node, grid);\r\n  for (const neighbor of neighbors) {\r\n    if (neighbor.distance === Infinity) {\r\n      neighbor.distance = node.distance + neighbor.weight;\r\n      directionChangeCheck(node, neighbor);\r\n      if (neighbor !== start) {\r\n        neighbor.previousNode = node;\r\n      }\r\n    } else {\r\n      const tempNeighborDistance = neighbor.distance;\r\n      const tempNeighborDirection = neighbor.direction;\r\n      const tempNeighborTieBreak = neighbor.tieBreak;\r\n\r\n      neighbor.distance = node.distance + neighbor.weight;\r\n      directionChangeCheck(node, neighbor);\r\n\r\n      if (neighbor !== start) {\r\n        if (\r\n          neighbor.distance + neighbor.tieBreak <\r\n          tempNeighborDistance + tempNeighborTieBreak\r\n        ) {\r\n          neighbor.previousNode = node;\r\n        } else if (\r\n          neighbor.distance + neighbor.tieBreak ===\r\n          tempNeighborDistance + tempNeighborTieBreak\r\n        ) {\r\n          const previousDist = lineDistance(neighbor.previousNode);\r\n          const nodeDist = lineDistance(node);\r\n          if (nodeDist > previousDist) {\r\n            neighbor.previousNode = node;\r\n          }\r\n        } else {\r\n          neighbor.distance = tempNeighborDistance;\r\n          neighbor.direction = tempNeighborDirection;\r\n          neighbor.tieBreak = tempNeighborTieBreak;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction directionChangeCheck(node, neighbor) {\r\n  if (node.row === neighbor.row) {\r\n    if (node.col > neighbor.col) {\r\n      neighbor.direction = \"left\";\r\n    } else {\r\n      neighbor.direction = \"right\";\r\n    }\r\n  }\r\n  if (node.col === neighbor.col) {\r\n    if (node.row > neighbor.row) {\r\n      neighbor.direction = \"up\";\r\n    } else {\r\n      neighbor.direction = \"down\";\r\n    }\r\n  }\r\n  if (node.direction !== null) {\r\n    if (node.direction !== neighbor.direction) {\r\n      neighbor.tieBreak = node.tieBreak + 1;\r\n    } else {\r\n      neighbor.tieBreak = node.tieBreak;\r\n    }\r\n  }\r\n}\r\n\r\nfunction lineDistance(node) {\r\n  const direction = node.direction;\r\n  var distance = 0;\r\n  while (node !== null) {\r\n    if (node.direction === direction) {\r\n      distance++;\r\n      node = node.previousNode;\r\n    } else {\r\n      return distance;\r\n    }\r\n  }\r\n  return distance;\r\n}\r\n\r\nfunction getNodeHeap(grid) {\r\n  var nodeHeap = new MinHeap();\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodeHeap.insert(node);\r\n    }\r\n  }\r\n  return nodeHeap;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function manhattan(start, finish) {\r\n  return Math.abs(start.row - finish.row) + Math.abs(start.col - finish.col);\r\n}\r\n\r\nexport function euclidian(start, finish) {\r\n  return Math.sqrt(\r\n    (start.row - finish.row) ** 2 + (start.col - finish.col) ** 2\r\n  );\r\n}\r\n\r\nexport function chebyshev(start, finish) {}\r\n\r\nexport function octile(start, finish) {}\r\n","import { MinHeap } from \"../data structures/minheap\";\r\nimport { manhattan, euclidian } from \"../heuristics\";\r\n\r\nexport function aStar(grid, start, finish, heuristic) {\r\n  const visitedNodesInOrder = [start];\r\n  start.distance = 0;\r\n  start.heuristicVal = getHeuristicVal(start, finish, heuristic);\r\n  start.directionChange = 0;\r\n\r\n  const unvisitedNodesHeap = getNodeHeap(grid, finish, heuristic);\r\n  updateNeighbors(start, finish, start, grid, heuristic);\r\n  unvisitedNodesHeap.heapify();\r\n  while (unvisitedNodesHeap.length > 0) {\r\n    const closestNode = unvisitedNodesHeap.extractMin();\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n    if (closestNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (closestNode === finish) {\r\n      visitedNodesInOrder.push(closestNode);\r\n      console.log(grid);\r\n      return visitedNodesInOrder;\r\n    }\r\n    visitedNodesInOrder.push(closestNode);\r\n    updateNeighbors(start, finish, closestNode, grid, heuristic);\r\n    unvisitedNodesHeap.heapify();\r\n  }\r\n}\r\n\r\nfunction getHeuristicVal(node, finish, heuristic) {\r\n  if (heuristic === \"manhattan\") {\r\n    return node.distance + manhattan(node, finish);\r\n  } else if (heuristic === \"euclidean\") {\r\n    return node.distance + euclidian(node, finish);\r\n  }\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  if (row < grid.length - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  if (col < grid[0].length - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  return neighbors;\r\n}\r\n\r\nfunction updateNeighbors(start, finish, node, grid, heuristic) {\r\n  const neighbors = getNeighbors(node, grid);\r\n  for (const neighbor of neighbors) {\r\n    if (neighbor !== start) {\r\n      if (neighbor.distance === Infinity) {\r\n        directionChangeCheck(node, neighbor);\r\n        neighbor.previousNode = node;\r\n        neighbor.distance = node.distance + neighbor.weight;\r\n        neighbor.heuristicVal = getHeuristicVal(neighbor, finish, heuristic);\r\n      } else {\r\n        const tempNeighborDistance = neighbor.distance;\r\n        const tempNeighborDirection = neighbor.direction;\r\n        const tempNeighborTieBreak = neighbor.tieBreak;\r\n\r\n        neighbor.distance = node.distance + neighbor.weight;\r\n        directionChangeCheck(node, neighbor);\r\n        if (\r\n          neighbor.heuristicVal >\r\n            getHeuristicVal(neighbor, finish, heuristic) ||\r\n          (neighbor.heuristicVal ===\r\n            getHeuristicVal(neighbor, finish, heuristic) &&\r\n            tempNeighborTieBreak > neighbor.tieBreak)\r\n        ) {\r\n          neighbor.previousNode = node;\r\n          neighbor.heuristicVal = getHeuristicVal(neighbor, finish, heuristic);\r\n        } else if (\r\n          neighbor.heuristicVal ===\r\n            getHeuristicVal(neighbor, finish, heuristic) &&\r\n          tempNeighborTieBreak === neighbor.tieBreak\r\n        ) {\r\n          const previousDist = lineDistance(neighbor.previousNode);\r\n          const nodeDist = lineDistance(node);\r\n          if (nodeDist > previousDist) {\r\n            neighbor.previousNode = node;\r\n            neighbor.heuristicVal = getHeuristicVal(\r\n              neighbor,\r\n              finish,\r\n              heuristic\r\n            );\r\n          }\r\n        } else {\r\n          neighbor.distance = tempNeighborDistance;\r\n          neighbor.direction = tempNeighborDirection;\r\n          neighbor.tieBreak = tempNeighborTieBreak;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction directionChangeCheck(node, neighbor) {\r\n  if (node.row === neighbor.row) {\r\n    if (node.col > neighbor.col) {\r\n      neighbor.direction = \"left\";\r\n    } else {\r\n      neighbor.direction = \"right\";\r\n    }\r\n  }\r\n  if (node.col === neighbor.col) {\r\n    if (node.row > neighbor.row) {\r\n      neighbor.direction = \"up\";\r\n    } else {\r\n      neighbor.direction = \"down\";\r\n    }\r\n  }\r\n  if (node.direction !== null) {\r\n    if (node.direction !== neighbor.direction) {\r\n      neighbor.tieBreak = node.tieBreak + 1;\r\n    } else {\r\n      neighbor.tieBreak = node.tieBreak;\r\n    }\r\n  }\r\n}\r\n\r\nfunction lineDistance(node) {\r\n  const direction = node.direction;\r\n  var distance = 0;\r\n  while (node !== null) {\r\n    if (node.direction === direction) {\r\n      distance++;\r\n      node = node.previousNode;\r\n    } else {\r\n      return distance;\r\n    }\r\n  }\r\n  return distance;\r\n}\r\n\r\nfunction getNodeHeap(grid, finish, heuristic) {\r\n  var nodeHeap = new MinHeap(finish, heuristic);\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodeHeap.insert(node);\r\n    }\r\n  }\r\n  nodeHeap.heapify();\r\n  return nodeHeap;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function depthFirst(grid, start, finish) {\r\n  const visitedNodesInOrder = [start];\r\n  start.isVisited = true;\r\n  start.distance = 0;\r\n  var nodesToVisit = getNeighbors(start, grid).reverse();\r\n  while (!!nodesToVisit.length) {\r\n    const node = nodesToVisit.shift();\r\n    visitedNodesInOrder.push(node);\r\n    if (node === finish) {\r\n      start.isVisited = false;\r\n      return visitedNodesInOrder;\r\n    }\r\n    node.isVisited = true;\r\n    var nodesToQueue = getNeighbors(node, grid);\r\n    for (const neighbor of nodesToQueue) {\r\n      nodesToVisit.unshift(neighbor);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const { col, row } = node;\r\n  var neighbor;\r\n  const neighbors = [];\r\n  if (row > 0) {\r\n    neighbor = updateNeighbor(node, grid[row - 1][col]);\r\n    if (neighbor !== null) {\r\n      neighbors.unshift(neighbor);\r\n    }\r\n  }\r\n  if (col < grid[0].length - 1) {\r\n    neighbor = updateNeighbor(node, grid[row][col + 1]);\r\n    if (neighbor !== null) {\r\n      neighbors.unshift(neighbor);\r\n    }\r\n  }\r\n\r\n  if (row < grid.length - 1) {\r\n    neighbor = updateNeighbor(node, grid[row + 1][col]);\r\n    if (neighbor !== null) {\r\n      neighbors.unshift(neighbor);\r\n    }\r\n  }\r\n  if (col > 0) {\r\n    neighbor = updateNeighbor(node, grid[row][col - 1]);\r\n    if (neighbor !== null) {\r\n      neighbors.unshift(neighbor);\r\n    }\r\n  }\r\n  return neighbors;\r\n}\r\n\r\nfunction updateNeighbor(node, neighbor) {\r\n  if (!neighbor.isWall && !neighbor.isVisited) {\r\n    neighbor.distance = node.distance + neighbor.weight;\r\n    neighbor.previousNode = node;\r\n    return neighbor;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import { MinHeap } from \"../data structures/minheap\";\r\nimport { manhattan, euclidian } from \"../heuristics\";\r\n\r\nexport function greedyBFS(grid, start, finish, heuristic) {\r\n  const visitedNodesInOrder = [start];\r\n  start.distance = 0;\r\n  start.heuristicVal = getHeuristicVal(start, finish, heuristic);\r\n\r\n  const unvisitedNodesHeap = getNodeHeap(grid, finish, heuristic);\r\n  updateNeighbors(start, finish, start, grid, heuristic);\r\n  unvisitedNodesHeap.heapify();\r\n  while (unvisitedNodesHeap.length > 0) {\r\n    const closestNode = unvisitedNodesHeap.extractMin();\r\n    if (closestNode.heuristicVal === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n    if (closestNode === finish) {\r\n      visitedNodesInOrder.push(closestNode);\r\n      return visitedNodesInOrder;\r\n    }\r\n    visitedNodesInOrder.push(closestNode);\r\n    updateNeighbors(start, finish, closestNode, grid, heuristic);\r\n    unvisitedNodesHeap.heapify();\r\n  }\r\n}\r\n\r\nfunction getHeuristicVal(node, finish, heuristic) {\r\n  if (heuristic === \"manhattan\") {\r\n    return manhattan(node, finish);\r\n  } else if (heuristic === \"euclidean\") {\r\n    return euclidian(node, finish);\r\n  }\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  if (row < grid.length - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  if (col < grid[0].length - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction updateNeighbors(start, finish, node, grid, heuristic) {\r\n  const neighbors = getNeighbors(node, grid);\r\n  for (const neighbor of neighbors) {\r\n    if (neighbor !== start && neighbor.previousNode === null) {\r\n      neighbor.previousNode = node;\r\n      neighbor.distance = node.distance + neighbor.weight;\r\n      neighbor.heuristicVal = getHeuristicVal(neighbor, finish, heuristic);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNodeHeap(grid, finish, heuristic) {\r\n  var nodeHeap = new MinHeap(finish, heuristic);\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodeHeap.insert(node);\r\n    }\r\n  }\r\n  nodeHeap.heapify();\r\n  return nodeHeap;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import { MinHeap } from \"../data structures/minheap\";\r\n\r\nexport function breadthFirst(grid, start, finish) {\r\n  const visitedNodesInOrder = [start];\r\n  start.distance = 0;\r\n\r\n  const unvisitedNodesHeap = getNodeHeap(grid);\r\n\r\n  while (unvisitedNodesHeap.length > 0) {\r\n    const closestNodes = [];\r\n    while (unvisitedNodesHeap.getMin().distance !== Infinity) {\r\n      closestNodes.push(unvisitedNodesHeap.extractMin());\r\n    }\r\n    sortNodes(closestNodes);\r\n    if (closestNodes.length === 0) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    for (const node of closestNodes) {\r\n      if (node.isWall) {\r\n        continue;\r\n      }\r\n      if (node === finish) {\r\n        visitedNodesInOrder.push(node);\r\n        return visitedNodesInOrder;\r\n      }\r\n      visitedNodesInOrder.push(node);\r\n      updateNeighbors(start, node, grid);\r\n      unvisitedNodesHeap.heapify();\r\n    }\r\n    unvisitedNodesHeap.heapify();\r\n  }\r\n}\r\n\r\n//Implement as min-heap instead of array?\r\nfunction sortNodes(unvisitedNodes) {\r\n  unvisitedNodes.sort((a, b) => a.row - b.row);\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  if (row < grid.length - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  if (col < grid[0].length - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  return neighbors;\r\n}\r\n\r\nfunction updateNeighbors(start, node, grid) {\r\n  const neighbors = getNeighbors(node, grid);\r\n  for (const neighbor of neighbors) {\r\n    if (neighbor.distance === Infinity) {\r\n      neighbor.distance = node.distance + 1;\r\n      directionChangeCheck(node, neighbor);\r\n      if (neighbor !== start) {\r\n        neighbor.previousNode = node;\r\n      }\r\n    } else {\r\n      const tempNeighborDistance = neighbor.distance;\r\n      const tempNeighborDirection = neighbor.direction;\r\n      const tempNeighborTieBreak = neighbor.tieBreak;\r\n\r\n      neighbor.distance = node.distance + neighbor.weight;\r\n      directionChangeCheck(node, neighbor);\r\n\r\n      if (neighbor !== start) {\r\n        if (\r\n          neighbor.distance + neighbor.tieBreak <\r\n          tempNeighborDistance + tempNeighborTieBreak\r\n        ) {\r\n          neighbor.previousNode = node;\r\n        } else if (\r\n          neighbor.distance + neighbor.tieBreak ===\r\n          tempNeighborDistance + tempNeighborTieBreak\r\n        ) {\r\n          const previousDist = lineDistance(neighbor.previousNode);\r\n          const nodeDist = lineDistance(node);\r\n          if (nodeDist > previousDist) {\r\n            neighbor.previousNode = node;\r\n          }\r\n        } else {\r\n          neighbor.distance = tempNeighborDistance;\r\n          neighbor.direction = tempNeighborDirection;\r\n          neighbor.tieBreak = tempNeighborTieBreak;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction directionChangeCheck(node, neighbor) {\r\n  if (node.row === neighbor.row) {\r\n    if (node.col > neighbor.col) {\r\n      neighbor.direction = \"left\";\r\n    } else {\r\n      neighbor.direction = \"right\";\r\n    }\r\n  }\r\n  if (node.col === neighbor.col) {\r\n    if (node.row > neighbor.row) {\r\n      neighbor.direction = \"up\";\r\n    } else {\r\n      neighbor.direction = \"down\";\r\n    }\r\n  }\r\n  if (node.direction !== null) {\r\n    if (node.direction !== neighbor.direction) {\r\n      neighbor.tieBreak = node.tieBreak + 1;\r\n    } else {\r\n      neighbor.tieBreak = node.tieBreak;\r\n    }\r\n  }\r\n}\r\n\r\nfunction lineDistance(node) {\r\n  const direction = node.direction;\r\n  var distance = 0;\r\n  while (node !== null) {\r\n    if (node.direction === direction) {\r\n      distance++;\r\n      node = node.previousNode;\r\n    } else {\r\n      return distance;\r\n    }\r\n  }\r\n  return distance;\r\n}\r\n\r\nfunction getNodeHeap(grid) {\r\n  var nodeHeap = new MinHeap();\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodeHeap.insert(node);\r\n    }\r\n  }\r\n  return nodeHeap;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function bidirectionalBFS(grid, start, finish) {\r\n  const nodes = getNodeList(grid);\r\n  const visitedStartNodes = [start];\r\n  const visitedFinishNodes = [finish];\r\n\r\n  start.distance = 0;\r\n  finish.distance = 0;\r\n\r\n  var neighborsFromStart, neighborsFromFinish, pathFoundStart, pathFoundFinish;\r\n\r\n  [neighborsFromStart, pathFoundStart] = updateNeighbors(\r\n    start,\r\n    start,\r\n    grid,\r\n    visitedStartNodes,\r\n    visitedFinishNodes,\r\n    false\r\n  );\r\n  [neighborsFromFinish, pathFoundFinish] = updateNeighbors(\r\n    finish,\r\n    finish,\r\n    grid,\r\n    visitedFinishNodes,\r\n    visitedStartNodes,\r\n    false\r\n  );\r\n\r\n  while (nodes.length > 0) {\r\n    var nextStartNeighbors = [];\r\n    var nextFinishNeighbors = [];\r\n    var neighborListLength = 0;\r\n    var updateData, pathFound;\r\n\r\n    if (neighborsFromStart.length > neighborsFromFinish.length) {\r\n      neighborListLength = neighborsFromStart.length;\r\n    } else {\r\n      neighborListLength = neighborsFromFinish.length;\r\n    }\r\n    sortNodes(neighborsFromStart);\r\n    sortNodes(neighborsFromFinish);\r\n    for (let i = 0; i < neighborListLength; i++) {\r\n      if (neighborsFromStart.length > i) {\r\n        const neighbor = neighborsFromStart[i];\r\n        if (!neighbor.isWall) {\r\n          if (\r\n            visitedFinishNodes.includes(neighbor) &&\r\n            neighbor.mergePoint !== null\r\n          ) {\r\n            return {\r\n              start: visitedStartNodes,\r\n              finish: visitedFinishNodes,\r\n              shortestPath: getShortestPath(neighbor, true),\r\n            };\r\n          } else {\r\n            visitedStartNodes.push(neighbor);\r\n            [updateData, pathFound] = updateNeighbors(\r\n              start,\r\n              neighbor,\r\n              grid,\r\n              visitedStartNodes,\r\n              visitedFinishNodes,\r\n              pathFoundStart\r\n            );\r\n            nextStartNeighbors = [...nextStartNeighbors, ...updateData];\r\n            if (!pathFoundStart) {\r\n              pathFoundStart = pathFound;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (neighborsFromFinish.length > i) {\r\n        const neighbor = neighborsFromFinish[i];\r\n        if (!neighbor.isWall) {\r\n          if (\r\n            visitedStartNodes.includes(neighbor) &&\r\n            neighbor.mergePoint !== null\r\n          ) {\r\n            return {\r\n              start: visitedStartNodes,\r\n              finish: visitedFinishNodes,\r\n              shortestPath: getShortestPath(neighbor, false),\r\n            };\r\n          } else {\r\n            visitedFinishNodes.push(neighbor);\r\n            [updateData, pathFound] = updateNeighbors(\r\n              finish,\r\n              neighbor,\r\n              grid,\r\n              visitedFinishNodes,\r\n              visitedStartNodes,\r\n              pathFoundFinish\r\n            );\r\n            nextFinishNeighbors = [...nextFinishNeighbors, ...updateData];\r\n            if (!pathFoundFinish) {\r\n              pathFoundFinish = pathFound;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (nextStartNeighbors.every((val) => neighborsFromStart.includes(val))) {\r\n      return {\r\n        start: visitedStartNodes,\r\n        finish: visitedFinishNodes,\r\n        shortestPath: [],\r\n      };\r\n    } else {\r\n      neighborsFromStart = removeDuplicates(nextStartNeighbors);\r\n    }\r\n    if (nextFinishNeighbors.every((val) => neighborsFromFinish.includes(val))) {\r\n      return {\r\n        start: visitedStartNodes,\r\n        finish: visitedFinishNodes,\r\n        shortestPath: [],\r\n      };\r\n    } else {\r\n      neighborsFromFinish = removeDuplicates(nextFinishNeighbors);\r\n    }\r\n  }\r\n}\r\n\r\n//Implement as min-heap instead of array?\r\nfunction sortNodes(unvisitedNodes) {\r\n  unvisitedNodes.sort((a, b) => a.row - b.row);\r\n}\r\n\r\nfunction removeDuplicates(list) {\r\n  return list.filter((value, index) => list.indexOf(value) === index);\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  if (row < grid.length - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  if (col < grid[0].length - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  return neighbors;\r\n}\r\n\r\nfunction updateNeighbors(\r\n  origin,\r\n  node,\r\n  grid,\r\n  visitedStartNodes,\r\n  visitedFinishNodes,\r\n  pathIsFound\r\n) {\r\n  const neighbors = getNeighbors(node, grid).filter(\r\n    (neighbor) => !visitedStartNodes.includes(neighbor)\r\n  );\r\n  for (const neighbor of neighbors) {\r\n    if (neighbor.previousNode === null && neighbor !== origin) {\r\n      neighbor.distance = node.distance + neighbor.weight;\r\n      neighbor.previousNode = node;\r\n    } else if (\r\n      neighbor !== origin &&\r\n      neighbor.previousNode !== null &&\r\n      visitedFinishNodes.includes(neighbor) &&\r\n      neighbor.mergePoint === null &&\r\n      node.previousNode !== neighbor &&\r\n      pathIsFound === false\r\n    ) {\r\n      neighbor.distance += node.distance + 1;\r\n      neighbor.mergePoint = node;\r\n      pathIsFound = true;\r\n    }\r\n  }\r\n  return [neighbors, pathIsFound];\r\n}\r\n\r\nfunction getNodeList(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction getShortestPath(node, isFromStart) {\r\n  const nodesInShortestPathOrder = [node];\r\n  if (isFromStart) {\r\n    let toStart = node.mergePoint;\r\n    while (toStart !== null) {\r\n      nodesInShortestPathOrder.unshift(toStart);\r\n      toStart = toStart.previousNode;\r\n    }\r\n    let toFinish = node.previousNode;\r\n    while (toFinish !== null) {\r\n      nodesInShortestPathOrder.push(toFinish);\r\n      toFinish = toFinish.previousNode;\r\n    }\r\n  } else {\r\n    let toStart = node.previousNode;\r\n    while (toStart !== null) {\r\n      nodesInShortestPathOrder.unshift(toStart);\r\n      toStart = toStart.previousNode;\r\n    }\r\n    let toFinish = node.mergePoint;\r\n    while (toFinish !== null) {\r\n      nodesInShortestPathOrder.push(toFinish);\r\n      toFinish = toFinish.previousNode;\r\n    }\r\n  }\r\n  nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1].distance =\r\n    node.distance;\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function generateSimpleMaze(grid) {\r\n  var prevGapCols = [];\r\n  for (let row = 0; row < grid.length; row++) {\r\n    const gapCols = [];\r\n    const wallCols = [];\r\n    //Assign Random Gaps in the Wall Columns\r\n    if (row % 2 === 0) {\r\n      for (var i = 0; i < 4; i++) {\r\n        gapCols.push(Math.floor(Math.random() * 10 + i * 10));\r\n      }\r\n    } else {\r\n      for (var i = 0; i < 2; i++) {\r\n        var randomWallCol = Math.floor(Math.random() * 20 + i * 20);\r\n        while (prevGapCols.includes(randomWallCol)) {\r\n          randomWallCol = Math.floor(Math.random() * 20 + i * 20);\r\n        }\r\n        wallCols.push(randomWallCol);\r\n      }\r\n    }\r\n\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      grid[row][col].isVisited = false;\r\n      if (grid[row][col].isWall === true) {\r\n        grid[row][col].isWall = false;\r\n      }\r\n      if (!grid[row][col].isStart && !grid[row][col].isFinish) {\r\n        if (\r\n          row === 0 ||\r\n          col === 0 ||\r\n          row === grid.length - 1 ||\r\n          col === grid[0].length - 1\r\n        ) {\r\n          grid[row][col].isWall = true;\r\n        } else if (\r\n          (!gapCols.includes(col) && row % 2 === 0) ||\r\n          (row % 2 !== 0 && wallCols.includes(col))\r\n        ) {\r\n          grid[row][col].isWall = true;\r\n        }\r\n      }\r\n    }\r\n    prevGapCols = gapCols;\r\n  }\r\n  return grid;\r\n}\r\n\r\nexport function generateRecursiveMaze(grid) {\r\n  for (var row = 0; row < grid.length; row++) {\r\n    for (var col = 0; col < grid[0].length; col++) {\r\n      grid[row][col].isVisited = false;\r\n      if (grid[row][col].isWall) {\r\n        grid[row][col].isWall = false;\r\n      }\r\n      if (\r\n        row === 0 ||\r\n        row === grid.length - 1 ||\r\n        col === 0 ||\r\n        col === grid[0].length - 1\r\n      ) {\r\n        grid[row][col].isWall = true;\r\n      }\r\n    }\r\n  }\r\n  recursiveMazeHelper(grid, 1, 1, grid.length - 2, grid[0].length - 2, []);\r\n  return grid;\r\n}\r\n\r\nfunction recursiveMazeHelper(\r\n  grid,\r\n  minRowNum,\r\n  minColNum,\r\n  maxRowNum,\r\n  maxColNum,\r\n  prevGapNeighbors\r\n) {\r\n  if (minRowNum >= maxRowNum || minColNum >= maxColNum) {\r\n    return;\r\n  }\r\n\r\n  if (maxColNum - minColNum >= maxRowNum - minRowNum) {\r\n    //horizontal\r\n    const possibleWallIndices = [];\r\n    const possibleGapIndices = [];\r\n    var gapNeighbors = [];\r\n    for (let i = minColNum + 1; i < maxColNum; i++) {\r\n      if (checkColWall(grid, i, minRowNum, maxRowNum, prevGapNeighbors)) {\r\n        possibleWallIndices.push(i);\r\n      }\r\n    }\r\n    for (let j = minRowNum; j <= maxRowNum; j++) {\r\n      possibleGapIndices.push(j);\r\n    }\r\n    if (possibleWallIndices.length < 1 || possibleGapIndices.length < 1) {\r\n      return;\r\n    }\r\n    const randomWallIndex =\r\n      possibleWallIndices[\r\n        Math.floor(Math.random() * possibleWallIndices.length)\r\n      ];\r\n\r\n    const randomGapIndex =\r\n      possibleGapIndices[Math.floor(Math.random() * possibleGapIndices.length)];\r\n\r\n    gapNeighbors.push(grid[randomGapIndex][randomWallIndex - 1]);\r\n    gapNeighbors.push(grid[randomGapIndex][randomWallIndex + 1]);\r\n\r\n    gapNeighbors = prevGapNeighbors.concat(gapNeighbors);\r\n\r\n    for (let r = minRowNum; r <= maxRowNum; r++) {\r\n      if (r !== randomGapIndex && isNotTerminalNode(grid, r, randomWallIndex)) {\r\n        grid[r][randomWallIndex].isWall = true;\r\n      }\r\n    }\r\n    recursiveMazeHelper(\r\n      grid,\r\n      minRowNum,\r\n      minColNum,\r\n      maxRowNum,\r\n      randomWallIndex - 1,\r\n      gapNeighbors\r\n    );\r\n    recursiveMazeHelper(\r\n      grid,\r\n      minRowNum,\r\n      randomWallIndex + 1,\r\n      maxRowNum,\r\n      maxColNum,\r\n      gapNeighbors\r\n    );\r\n  } else {\r\n    //vertical\r\n    const possibleWallIndices = [];\r\n    const possibleGapIndices = [];\r\n    var gapNeighbors = [];\r\n    for (let i = minRowNum + 1; i < maxRowNum; i++) {\r\n      if (checkRowWall(grid, i, minColNum, maxColNum, prevGapNeighbors)) {\r\n        possibleWallIndices.push(i);\r\n      }\r\n    }\r\n    for (let j = minColNum; j <= maxColNum; j++) {\r\n      possibleGapIndices.push(j);\r\n    }\r\n    if (possibleWallIndices.length < 1 || possibleGapIndices.length < 1) {\r\n      return;\r\n    }\r\n    const randomWallIndex =\r\n      possibleWallIndices[\r\n        Math.floor(Math.random() * possibleWallIndices.length)\r\n      ];\r\n\r\n    const randomGapIndex =\r\n      possibleGapIndices[Math.floor(Math.random() * possibleGapIndices.length)];\r\n\r\n    gapNeighbors.push(grid[randomWallIndex - 1][randomGapIndex]);\r\n    gapNeighbors.push(grid[randomWallIndex + 1][randomGapIndex]);\r\n\r\n    gapNeighbors = prevGapNeighbors.concat(gapNeighbors);\r\n\r\n    for (let c = minColNum; c <= maxColNum; c++) {\r\n      if (c !== randomGapIndex && isNotTerminalNode(grid, randomWallIndex, c)) {\r\n        grid[randomWallIndex][c].isWall = true;\r\n      }\r\n    }\r\n    recursiveMazeHelper(\r\n      grid,\r\n      minRowNum,\r\n      minColNum,\r\n      randomWallIndex - 1,\r\n      maxColNum,\r\n      gapNeighbors\r\n    );\r\n    recursiveMazeHelper(\r\n      grid,\r\n      randomWallIndex + 1,\r\n      minColNum,\r\n      maxRowNum,\r\n      maxColNum,\r\n      gapNeighbors\r\n    );\r\n  }\r\n}\r\n\r\nfunction isNotTerminalNode(grid, row, col) {\r\n  return !grid[row][col].isStart && !grid[row][col].isFinish;\r\n}\r\n\r\nfunction checkColWall(grid, col, minRow, maxRow, prevGapNeighbors) {\r\n  for (const node of prevGapNeighbors) {\r\n    if (node.col === col && node.row >= minRow && node.row <= maxRow) {\r\n      return false;\r\n    }\r\n  }\r\n  for (var r = minRow; r <= maxRow; r++) {\r\n    const node = grid[r][col];\r\n    if (node.isStart || node.isFinish) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction checkRowWall(grid, row, minCol, maxCol, prevGapNeighbors) {\r\n  for (const node of prevGapNeighbors) {\r\n    if (node.row === row && node.col >= minCol && node.col <= maxCol) {\r\n      return false;\r\n    }\r\n  }\r\n  for (var c = minCol; c <= maxCol; c++) {\r\n    const node = grid[row][c];\r\n    if (node.isStart || node.isFinish) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function generateVShapeMaze(grid) {\r\n  var offset = 0;\r\n  for (var row = 0; row < grid.length; row++) {\r\n    for (var col = 0; col < grid[0].length; col++) {\r\n      grid[row][col].isVisited = false;\r\n      grid[row][col].isWall = false;\r\n    }\r\n  }\r\n  for (let row = 2; row < grid.length; row++) {\r\n    grid[row][row - 1].isWall = true;\r\n  }\r\n  for (let row = 23; row > 3; row--) {\r\n    grid[row][24 + offset].isWall = true;\r\n    offset++;\r\n  }\r\n  return grid;\r\n}\r\n\r\nexport function generateRandomMaze(grid) {\r\n  for (var row = 0; row < grid.length; row++) {\r\n    for (var col = 0; col < grid[0].length; col++) {\r\n      if (!grid[row][col].isStart && !grid[row][col].isFinish) {\r\n        if (grid[row][col].isWall) {\r\n          grid[row][col].isWall = false;\r\n        }\r\n        const wallDecider = Math.floor(Math.random() * 10);\r\n        if (wallDecider < 3) {\r\n          grid[row][col].isWall = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return grid;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\r\nimport { aStar } from \"../algorithms/a-star\";\r\nimport { depthFirst } from \"../algorithms/depth-first\";\r\nimport { greedyBFS } from \"../algorithms/best-first\";\r\nimport { breadthFirst } from \"../algorithms/breadth-first\";\r\nimport { bidirectionalBFS } from \"../algorithms/bidirectionalBFS\";\r\n\r\nimport {\r\n  generateRandomMaze,\r\n  generateVShapeMaze,\r\n  generateSimpleMaze,\r\n  generateRecursiveMaze,\r\n} from \"../mazeGenerator\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nconst weightDictionary = {\r\n  goblin: 2,\r\n  ogre: 5,\r\n  witch: 10,\r\n  bear: 15,\r\n  dragon: 25,\r\n};\r\n\r\nvar START_NODE_ROW = 12;\r\nvar START_NODE_COL = 5;\r\nvar FINISH_NODE_ROW = 12;\r\nvar FINISH_NODE_COL = 39;\r\n\r\nconst GRID_ROW_NUM = 25;\r\nconst GRID_COL_NUM = 45;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      boardIsCleared: true,\r\n      mouseIsPressed: false,\r\n      wallSelected: true,\r\n      pressedStart: false,\r\n      pressedFinish: false,\r\n      algorithm: null,\r\n      heuristic: null,\r\n      obstacle: \"wall\",\r\n      speed: 1,\r\n      visitedNodes: 0,\r\n      totalCost: 0,\r\n    };\r\n  }\r\n\r\n  setAlgorithm(algorithmName) {\r\n    const newGrid = this.state.grid.slice();\r\n    if (!document.getElementById(\"visualize\").disabled) {\r\n      resetGrid(newGrid);\r\n    }\r\n    if (algorithmName !== \"greedy\" && algorithmName !== \"a*\") {\r\n      disableListElementButton(\"manhattan\");\r\n      disableListElementButton(\"euclidean\");\r\n    } else {\r\n      enableListElementButton(\"manhattan\");\r\n      enableListElementButton(\"euclidean\");\r\n    }\r\n    if (algorithmName === \"breadth\" || algorithmName === \"depth\") {\r\n      disableListElementButton(\"goblin\");\r\n      disableListElementButton(\"ogre\");\r\n      disableListElementButton(\"witch\");\r\n      disableListElementButton(\"bear\");\r\n      disableListElementButton(\"dragon\");\r\n      this.setState({\r\n        algorithm: algorithmName,\r\n        obstacle: \"wall\",\r\n        grid: newGrid,\r\n      });\r\n    } else {\r\n      enableListElementButton(\"goblin\");\r\n      enableListElementButton(\"ogre\");\r\n      enableListElementButton(\"witch\");\r\n      enableListElementButton(\"bear\");\r\n      enableListElementButton(\"dragon\");\r\n      this.setState({ algorithm: algorithmName, grid: newGrid });\r\n    }\r\n  }\r\n\r\n  setHeuristic(heuristicName) {\r\n    if (!document.getElementById(heuristicName).disabled) {\r\n      this.setState({ heuristic: heuristicName });\r\n    }\r\n  }\r\n  setObstacle(obstacleName) {\r\n    if (obstacleName !== \"wall\") {\r\n      if (!document.getElementById(obstacleName).disabled) {\r\n        this.setState({ obstacle: obstacleName });\r\n      }\r\n    } else {\r\n      this.setState({ obstacle: obstacleName });\r\n    }\r\n  }\r\n\r\n  setSpeed(speedVal) {\r\n    this.setState({ speed: speedVal });\r\n  }\r\n\r\n  setVisitedNodes(nodeNum) {\r\n    this.setState({ visitedNodes: nodeNum });\r\n  }\r\n\r\n  setCost(costVal) {\r\n    this.setState({ totalCost: costVal });\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    if (row === START_NODE_ROW && col === START_NODE_COL) {\r\n      this.setState({ pressedStart: true, mouseIsPressed: true });\r\n    } else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\r\n      this.setState({ pressedFinish: true, mouseIsPressed: true });\r\n    } else {\r\n      if (this.state.obstacle === \"wall\") {\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({\r\n          grid: newGrid,\r\n          mouseIsPressed: true,\r\n          wallSelected: true,\r\n        });\r\n      } else {\r\n        const newGrid = getNewGridWithObstacleToggled(\r\n          this.state.grid,\r\n          row,\r\n          col,\r\n          this.state.obstacle\r\n        );\r\n        this.setState({\r\n          grid: newGrid,\r\n          mouseIsPressed: true,\r\n          wallSelected: false,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) {\r\n      return;\r\n    }\r\n    if (this.state.pressedStart) {\r\n      const newGrid = updateStartNode(this.state.grid, row, col);\r\n      if (newGrid !== null) {\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    } else if (this.state.pressedFinish) {\r\n      const newGrid = updateFinishNode(this.state.grid, row, col);\r\n      if (newGrid !== null) {\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    } else if (this.state.wallSelected) {\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n    } else {\r\n      const newGrid = getNewGridWithObstacleToggled(\r\n        this.state.grid,\r\n        row,\r\n        col,\r\n        this.state.obstacle\r\n      );\r\n      this.setState({ grid: newGrid });\r\n    }\r\n  }\r\n\r\n  handleMouseUp() {\r\n    if (this.state.pressedStart) {\r\n      this.setState({ pressedStart: false });\r\n    } else if (this.state.pressedFinish) {\r\n      this.setState({ pressedFinish: false });\r\n    }\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  clearBoard() {\r\n    const { grid } = this.state;\r\n    const newGrid = clearGrid(grid);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  resetBoard() {\r\n    const { grid } = this.state;\r\n    const newGrid = resetGrid(grid);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  updateGrid(newGrid) {\r\n    const newMazeGrid = resetGrid(newGrid);\r\n    this.setState({ grid: newMazeGrid });\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    const speed = 1 / parseFloat(this.state.speed);\r\n    for (let i = 0; i <= nodesInShortestPathOrder.length; i++) {\r\n      if (i === nodesInShortestPathOrder.length) {\r\n        setTimeout(() => {\r\n          enableButton(\"visualize\");\r\n          enableButton(\"clear\");\r\n          enableButton(\"reset\");\r\n          enableMazeButtons();\r\n        }, 30 * speed * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          if (\r\n            !(\r\n              (node.row === START_NODE_ROW && node.col === START_NODE_COL) ||\r\n              (node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL)\r\n            )\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-path\";\r\n          }\r\n        }, 30 * speed * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    const speed = 1 / parseFloat(this.state.speed);\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.setVisitedNodes(i);\r\n          this.setCost(\r\n            nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1]\r\n              .distance\r\n          );\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 20 * speed * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n          if (\r\n            !(\r\n              (node.row === START_NODE_ROW && node.col === START_NODE_COL) ||\r\n              (node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL)\r\n            )\r\n          ) {\r\n            if (node.obstacleType === null) {\r\n              document.getElementById(\r\n                `node-${node.row}-${node.col}`\r\n              ).className = \"node node-visited\";\r\n            } else {\r\n              document.getElementById(\r\n                `node-${node.row}-${node.col}`\r\n              ).className = `node node-${node.obstacleType}-visited`;\r\n            }\r\n          }\r\n        }, 20 * speed * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  animateBidirectional(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    const speed = 1 / parseFloat(this.state.speed);\r\n    const visitedFromStart = visitedNodesInOrder[\"start\"];\r\n    const visitedFromFinish = visitedNodesInOrder[\"finish\"];\r\n    var visitedLength;\r\n    if (visitedFromFinish.length > visitedFromStart.length) {\r\n      visitedLength = visitedFromFinish.length;\r\n    } else {\r\n      visitedLength = visitedFromStart.length;\r\n    }\r\n\r\n    for (let i = 0; i <= visitedLength; i++) {\r\n      if (i === visitedLength) {\r\n        setTimeout(() => {\r\n          this.setVisitedNodes(i);\r\n          this.setCost(\r\n            nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1]\r\n              .distance\r\n          );\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 20 * speed * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          if (i < visitedFromStart.length) {\r\n            const nodeFromStart = visitedFromStart[i];\r\n            if (\r\n              !(\r\n                (nodeFromStart.row === START_NODE_ROW &&\r\n                  nodeFromStart.col === START_NODE_COL) ||\r\n                (nodeFromStart.row === FINISH_NODE_ROW &&\r\n                  nodeFromStart.col === FINISH_NODE_COL)\r\n              )\r\n            ) {\r\n              if (nodeFromStart.obstacleType === null) {\r\n                document.getElementById(\r\n                  `node-${nodeFromStart.row}-${nodeFromStart.col}`\r\n                ).className = \"node node-visited\";\r\n              } else {\r\n                document.getElementById(\r\n                  `node-${nodeFromStart.row}-${nodeFromStart.col}`\r\n                ).className = `node node-${nodeFromStart.obstacleType}-visited`;\r\n              }\r\n            }\r\n          }\r\n          if (i < visitedFromFinish.length) {\r\n            const nodeFromFinish = visitedFromFinish[i];\r\n            if (\r\n              !(\r\n                (nodeFromFinish.row === START_NODE_ROW &&\r\n                  nodeFromFinish.col === START_NODE_COL) ||\r\n                (nodeFromFinish.row === FINISH_NODE_ROW &&\r\n                  nodeFromFinish.col === FINISH_NODE_COL)\r\n              )\r\n            ) {\r\n              if (nodeFromFinish.obstacleType === null) {\r\n                document.getElementById(\r\n                  `node-${nodeFromFinish.row}-${nodeFromFinish.col}`\r\n                ).className = \"node node-visited\";\r\n              } else {\r\n                document.getElementById(\r\n                  `node-${nodeFromFinish.row}-${nodeFromFinish.col}`\r\n                ).className = `node node-${nodeFromFinish.obstacleType}-visited`;\r\n              }\r\n            }\r\n          }\r\n        }, 20 * speed * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  visualizeAlgorithm(algorithmID, heuristicID) {\r\n    const { grid } = this.state;\r\n    disableButton(\"visualize\");\r\n    disableButton(\"clear\");\r\n    disableButton(\"reset\");\r\n    disableMazeButtons();\r\n    if (algorithmID === null) {\r\n      alert(\"Please select an algorithm!\");\r\n      enableButton(\"visualize\");\r\n      enableButton(\"clear\");\r\n      enableButton(\"reset\");\r\n      enableMazeButtons();\r\n      return;\r\n    }\r\n    if (!this.state.boardIsCleared) {\r\n      resetGrid(grid);\r\n    } else {\r\n      this.setState({ boardIsCleared: false });\r\n    }\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var visitedNodesInOrder;\r\n    if (algorithmID === \"dijkstra\") {\r\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    } else if (algorithmID === \"a*\") {\r\n      if (heuristicID === null) {\r\n        alert(\"Please select a heuristic!\");\r\n        enableButton(\"visualize\");\r\n        enableButton(\"clear\");\r\n        enableButton(\"reset\");\r\n        enableMazeButtons();\r\n        return;\r\n      }\r\n      visitedNodesInOrder = aStar(grid, startNode, finishNode, heuristicID);\r\n    } else if (algorithmID === \"depth\") {\r\n      visitedNodesInOrder = depthFirst(grid, startNode, finishNode);\r\n    } else if (algorithmID === \"greedy\") {\r\n      if (heuristicID === null) {\r\n        alert(\"Please select a heuristic!\");\r\n        enableButton(\"visualize\");\r\n        enableButton(\"clear\");\r\n        enableButton(\"reset\");\r\n        enableMazeButtons();\r\n        return;\r\n      }\r\n      visitedNodesInOrder = greedyBFS(grid, startNode, finishNode, heuristicID);\r\n    } else if (algorithmID === \"breadth\") {\r\n      visitedNodesInOrder = breadthFirst(grid, startNode, finishNode);\r\n    } else if (algorithmID === \"bidirectional\") {\r\n      visitedNodesInOrder = bidirectionalBFS(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder = visitedNodesInOrder[\"shortestPath\"];\r\n      this.setVisitedNodes(null);\r\n      this.setCost(null);\r\n      this.animateBidirectional(\r\n        {\r\n          start: visitedNodesInOrder[\"start\"],\r\n          finish: visitedNodesInOrder[\"finish\"],\r\n        },\r\n        nodesInShortestPathOrder\r\n      );\r\n      return;\r\n    }\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.setVisitedNodes(null);\r\n    this.setCost(null);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    return (\r\n      <>\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n        <link\r\n          rel=\"styles\"\r\n          href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\"\r\n        />\r\n        <link\r\n          rel=\"stylesheet\"\r\n          href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\"\r\n        />\r\n        <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>\r\n        <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js\"></script>\r\n        <script src=\"//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\r\n        <ul>\r\n          <li style={{ marginLeft: \"95px\" }} className=\"dropdown\">\r\n            <a className=\"dropbtn\" data-toggle=\"dropdown-content\">\r\n              {getAlgorithmButtonContent(this.state.algorithm)}{\" \"}\r\n              <i className=\"fa fa-caret-down\"></i>\r\n            </a>\r\n            <div className=\"dropdown-content\">\r\n              <a onClick={() => this.setAlgorithm(\"dijkstra\")}>Dijkstra</a>\r\n              <a onClick={() => this.setAlgorithm(\"a*\")}>A*</a>\r\n              <a onClick={() => this.setAlgorithm(\"greedy\")}>\r\n                Greedy Best First Search\r\n              </a>\r\n              <a onClick={() => this.setAlgorithm(\"breadth\")}>\r\n                Breadth First Search\r\n              </a>\r\n              <a onClick={() => this.setAlgorithm(\"bidirectional\")}>\r\n                Bidirectional Breadth First Search\r\n              </a>\r\n              <a onClick={() => this.setAlgorithm(\"depth\")}>\r\n                Depth First Search\r\n              </a>\r\n            </div>\r\n          </li>\r\n          <li className=\"dropdown\">\r\n            <a className=\"dropbtn-med\">\r\n              {getHeuristicButtonContent(this.state.heuristic)}{\" \"}\r\n              <i className=\"fa fa-caret-down\"></i>\r\n            </a>\r\n            <div className=\"dropdown-content-sml\">\r\n              <a\r\n                id=\"manhattan\"\r\n                onClick={() => this.setHeuristic(\"manhattan\")}\r\n                onMouseOver={() => mouseListElementHover(\"manhattan\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"manhattan\")}\r\n              >\r\n                Manhattan\r\n              </a>\r\n              <a\r\n                id=\"euclidean\"\r\n                onClick={() => this.setHeuristic(\"euclidean\")}\r\n                onMouseOver={() => mouseListElementHover(\"euclidean\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"euclidean\")}\r\n              >\r\n                Euclidean\r\n              </a>\r\n            </div>\r\n          </li>\r\n          <li className=\"dropdown\">\r\n            <a className=\"dropbtn-sml\">\r\n              {getObstacleButtonContent(this.state.obstacle)}{\" \"}\r\n              <i className=\"fa fa-caret-down\"></i>\r\n            </a>\r\n            <div className=\"dropdown-content-sml\">\r\n              <a onClick={() => this.setObstacle(\"wall\")}>\r\n                Wall (Cost: Infinity)\r\n              </a>\r\n              <a\r\n                id=\"goblin\"\r\n                onClick={() => this.setObstacle(\"goblin\")}\r\n                onMouseOver={() => mouseListElementHover(\"goblin\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"goblin\")}\r\n              >\r\n                Goblin (Cost: 2)\r\n              </a>\r\n              <a\r\n                id=\"ogre\"\r\n                onClick={() => this.setObstacle(\"ogre\")}\r\n                onMouseOver={() => mouseListElementHover(\"ogre\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"ogre\")}\r\n              >\r\n                Ogre (Cost: 5)\r\n              </a>\r\n              <a\r\n                id=\"witch\"\r\n                onClick={() => this.setObstacle(\"witch\")}\r\n                onMouseOver={() => mouseListElementHover(\"witch\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"witch\")}\r\n              >\r\n                Witch (Cost: 10)\r\n              </a>\r\n              <a\r\n                id=\"bear\"\r\n                onClick={() => this.setObstacle(\"bear\")}\r\n                onMouseOver={() => mouseListElementHover(\"bear\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"bear\")}\r\n              >\r\n                Bear (Cost: 15)\r\n              </a>\r\n              <a\r\n                id=\"dragon\"\r\n                onClick={() => this.setObstacle(\"dragon\")}\r\n                onMouseOver={() => mouseListElementHover(\"dragon\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"dragon\")}\r\n              >\r\n                Dragon (Cost: 25)\r\n              </a>\r\n            </div>\r\n          </li>\r\n          <li className=\"dropdown\">\r\n            <a className=\"dropbtn-sml\">\r\n              Mazes <i className=\"fa fa-caret-down\"></i>\r\n            </a>\r\n            <div className=\"dropdown-content-sml\">\r\n              <a\r\n                id=\"simple\"\r\n                onClick={() => this.updateGrid(generateSimpleMaze(grid))}\r\n                onMouseOver={() => mouseListElementHover(\"simple\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"simple\")}\r\n              >\r\n                Simple Maze\r\n              </a>\r\n              <a\r\n                id=\"recursive\"\r\n                onClick={() => this.updateGrid(generateRecursiveMaze(grid))}\r\n                onMouseOver={() => mouseListElementHover(\"recursive\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"recursive\")}\r\n              >\r\n                Recursive Division\r\n              </a>\r\n              <a\r\n                id=\"v\"\r\n                onClick={() => this.updateGrid(generateVShapeMaze(grid))}\r\n                onMouseOver={() => mouseListElementHover(\"v\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"v\")}\r\n              >\r\n                V-Shape\r\n              </a>\r\n              <a\r\n                id=\"random\"\r\n                onClick={() => this.updateGrid(generateRandomMaze(grid))}\r\n                onMouseOver={() => mouseListElementHover(\"random\")}\r\n                onMouseLeave={() => mouseListElementLeave(\"random\")}\r\n              >\r\n                Random\r\n              </a>\r\n            </div>\r\n          </li>\r\n          <li className=\"dropdown\">\r\n            <a className=\"dropbtn-med\">\r\n              {getSpeedButtonContent(this.state.speed)}{\" \"}\r\n              <i className=\"fa fa-caret-down\"></i>\r\n            </a>\r\n            <div className=\"dropdown-content-sml\">\r\n              <a onClick={() => this.setSpeed(0.5)}>Slow (0.5x)</a>\r\n              <a onClick={() => this.setSpeed(1)}>Normal (1.0x)</a>\r\n              <a onClick={() => this.setSpeed(2)}>Fast (2.0x)</a>\r\n              <a onClick={() => this.setSpeed(4)}>Rapid (4.0x)</a>\r\n            </div>\r\n          </li>\r\n          <li style={{ float: \"right\", marginRight: \"120px\" }}>\r\n            <a\r\n              className=\"smlbtn\"\r\n              onClick={() => this.clearBoard()}\r\n              id=\"clear\"\r\n              onMouseOver={() => mouseHover(\"clear\")}\r\n              onMouseLeave={() => mouseLeave(\"clear\")}\r\n            >\r\n              Clear Board\r\n            </a>\r\n          </li>\r\n          <li style={{ float: \"right\" }}>\r\n            <a\r\n              className=\"smlbtn\"\r\n              onClick={() => this.resetBoard()}\r\n              id=\"reset\"\r\n              onMouseOver={() => mouseHover(\"reset\")}\r\n              onMouseLeave={() => mouseLeave(\"reset\")}\r\n            >\r\n              Reset Board\r\n            </a>\r\n          </li>\r\n          <li style={{ float: \"right\" }}>\r\n            <button\r\n              onClick={() =>\r\n                this.visualizeAlgorithm(\r\n                  this.state.algorithm,\r\n                  this.state.heuristic\r\n                )\r\n              }\r\n              onMouseOver={() => mouseHover(\"visualize\")}\r\n              onMouseLeave={() => mouseLeave(\"visualize\")}\r\n              id=\"visualize\"\r\n            >\r\n              {getVisualizeButtonContent(\r\n                this.state.algorithm,\r\n                this.state.heuristic\r\n              )}\r\n            </button>\r\n          </li>\r\n        </ul>\r\n\r\n        <br></br>\r\n        <h3 style={{ padding: \"0\", margin: \"0\" }} id=\"analytics\">\r\n          {getAnalyticsContent(this.state.visitedNodes, this.state.totalCost)}\r\n        </h3>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    isWall,\r\n                    obstacleType,\r\n                    isVisited,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      row={row}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      isWall={isWall}\r\n                      obstacleType={obstacleType}\r\n                      isVisited={isVisited}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst updateStartNode = (grid, row, col) => {\r\n  if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\r\n    return null;\r\n  }\r\n  const newGrid = grid.slice();\r\n  const oldStartNode = newGrid[START_NODE_ROW][START_NODE_COL];\r\n  const newNode = {\r\n    ...oldStartNode,\r\n    isStart: false,\r\n  };\r\n  newGrid[START_NODE_ROW][START_NODE_COL] = newNode;\r\n\r\n  const startNode = newGrid[row][col];\r\n  const newStartNode = {\r\n    ...startNode,\r\n    isStart: true,\r\n  };\r\n  newGrid[row][col] = newStartNode;\r\n\r\n  START_NODE_ROW = row;\r\n  START_NODE_COL = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nconst updateFinishNode = (grid, row, col) => {\r\n  if (row === START_NODE_ROW && col === START_NODE_COL) {\r\n    return null;\r\n  }\r\n  const newGrid = grid.slice();\r\n  const oldFinishNode = newGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n  const newNode = {\r\n    ...oldFinishNode,\r\n    isFinish: false,\r\n  };\r\n  newGrid[FINISH_NODE_ROW][FINISH_NODE_COL] = newNode;\r\n\r\n  const finishNode = newGrid[row][col];\r\n  const newFinishNode = {\r\n    ...finishNode,\r\n    isFinish: true,\r\n  };\r\n  newGrid[row][col] = newFinishNode;\r\n\r\n  FINISH_NODE_ROW = row;\r\n  FINISH_NODE_COL = col;\r\n\r\n  return newGrid;\r\n};\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < GRID_ROW_NUM; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < GRID_COL_NUM; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst clearGrid = (grid) => {\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      resetNode(grid, row, col, true);\r\n      if (\r\n        !(\r\n          (row === START_NODE_ROW && col === START_NODE_COL) ||\r\n          (row === FINISH_NODE_ROW && col === FINISH_NODE_COL)\r\n        )\r\n      ) {\r\n        document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n      }\r\n    }\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst resetGrid = (grid) => {\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      resetNode(grid, row, col, false);\r\n      if (\r\n        !(\r\n          (row === START_NODE_ROW && col === START_NODE_COL) ||\r\n          (row === FINISH_NODE_ROW && col === FINISH_NODE_COL)\r\n        ) &&\r\n        !grid[row][col].isWall\r\n      )\r\n        if (grid[row][col].obstacleType === null) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        } else {\r\n          document.getElementById(\r\n            `node-${row}-${col}`\r\n          ).className = `node node-${grid[row][col].obstacleType}`;\r\n        }\r\n    }\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col: col,\r\n    row: row,\r\n    weight: 1,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    obstacleType: null,\r\n    distance: Infinity,\r\n    heuristicVal: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    direction: null,\r\n    tieBreak: 0,\r\n    previousNode: null,\r\n    mergePoint: null,\r\n  };\r\n};\r\n\r\nconst resetNode = (grid, row, col, hardReset) => {\r\n  if (hardReset) {\r\n    grid[row][col].weight = 1;\r\n    grid[row][col].isWall = false;\r\n    grid[row][col].obstacleType = null;\r\n  }\r\n  grid[row][col].distance = Infinity;\r\n  grid[row][col].heuristicVal = Infinity;\r\n  grid[row][col].isVisited = false;\r\n  grid[row][col].previousNode = null;\r\n  grid[row][col].mergePoint = null;\r\n  grid[row][col].direction = null;\r\n  grid[row][col].tieBreak = 0;\r\n};\r\n\r\nconst getNewGridWithObstacleToggled = (grid, row, col, obstacleName) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  if (node.obstacleType === obstacleName) {\r\n    const newNode = {\r\n      ...node,\r\n      obstacleType: null,\r\n      weight: 1,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  } else {\r\n    const newNode = {\r\n      ...node,\r\n      obstacleType: obstacleName,\r\n      weight: weightDictionary[obstacleName],\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    obstacleType: null,\r\n    weight: 1,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst disableButton = (elementId) => {\r\n  const button = document.getElementById(elementId);\r\n  button.disabled = true;\r\n  button.style.cursor = \"not-allowed\";\r\n  button.style.backgroundColor = \"rgba(255,0,0,0.65)\";\r\n};\r\n\r\nconst enableButton = (elementId) => {\r\n  const button = document.getElementById(elementId);\r\n  button.disabled = false;\r\n  button.style.cursor = \"pointer\";\r\n  button.style.backgroundColor = \"#735983\";\r\n};\r\n\r\nconst disableListElementButton = (elementId) => {\r\n  const button = document.getElementById(elementId);\r\n  button.disabled = true;\r\n  button.style.cursor = \"not-allowed\";\r\n  button.style.backgroundColor = \"lightgray\";\r\n};\r\n\r\nconst enableListElementButton = (elementId) => {\r\n  const button = document.getElementById(elementId);\r\n  button.disabled = false;\r\n  button.style.cursor = \"pointer\";\r\n  button.style.backgroundColor = \"white\";\r\n};\r\n\r\nconst mouseHover = (elementId) => {\r\n  if (document.getElementById(elementId).disabled === false)\r\n    document.getElementById(elementId).style.backgroundColor = \"#CC6686\";\r\n};\r\n\r\nconst mouseLeave = (elementId) => {\r\n  if (document.getElementById(elementId).disabled === false)\r\n    document.getElementById(elementId).style.backgroundColor = \"#735983\";\r\n};\r\n\r\nconst mouseListElementHover = (elementId) => {\r\n  if (document.getElementById(elementId).disabled === false)\r\n    document.getElementById(elementId).style.backgroundColor = \"#ff687e\";\r\n};\r\n\r\nconst mouseListElementLeave = (elementId) => {\r\n  if (document.getElementById(elementId).disabled === false)\r\n    document.getElementById(elementId).style.backgroundColor = \"white\";\r\n};\r\n\r\nconst disableMazeButtons = () => {\r\n  disableListElementButton(\"simple\");\r\n  disableListElementButton(\"recursive\");\r\n  disableListElementButton(\"v\");\r\n  disableListElementButton(\"random\");\r\n};\r\n\r\nconst enableMazeButtons = () => {\r\n  enableListElementButton(\"simple\");\r\n  enableListElementButton(\"recursive\");\r\n  enableListElementButton(\"v\");\r\n  enableListElementButton(\"random\");\r\n};\r\n\r\nconst getAlgorithmButtonContent = (algorithmID) => {\r\n  if (algorithmID === null) {\r\n    return \"Select an Algorithm\";\r\n  } else {\r\n    if (algorithmID === \"dijkstra\") {\r\n      return \"Dijkstra's Algorithm\";\r\n    } else if (algorithmID === \"breadth\") {\r\n      return \"Breadth First Search\";\r\n    } else if (algorithmID === \"bidirectional\") {\r\n      return \"Bidirectional Search\";\r\n    } else if (algorithmID === \"depth\") {\r\n      return \"Depth First Search\";\r\n    } else if (algorithmID === \"a*\") {\r\n      return \"A* Search\";\r\n    } else {\r\n      return \"Greedy Best First Search\";\r\n    }\r\n  }\r\n};\r\n\r\nconst getHeuristicButtonContent = (heuristicID) => {\r\n  if (heuristicID === null) {\r\n    return \"Select a heuristic\";\r\n  } else {\r\n    if (heuristicID === \"manhattan\") {\r\n      return \"Manhattan\";\r\n    } else if (heuristicID === \"euclidean\") {\r\n      return \"Euclidean\";\r\n    }\r\n  }\r\n};\r\n\r\nconst getObstacleButtonContent = (obstacleID) => {\r\n  if (obstacleID === null) {\r\n    return \"Select an obstacle\";\r\n  } else {\r\n    if (obstacleID === \"wall\") {\r\n      return \"Wall\";\r\n    } else if (obstacleID === \"goblin\") {\r\n      return \"Goblin\";\r\n    } else if (obstacleID === \"ogre\") {\r\n      return \"Ogre\";\r\n    } else if (obstacleID === \"witch\") {\r\n      return \"Witch\";\r\n    } else if (obstacleID === \"bear\") {\r\n      return \"Bear\";\r\n    } else {\r\n      return \"Dragon\";\r\n    }\r\n  }\r\n};\r\n\r\nconst getSpeedButtonContent = (speedVal) => {\r\n  if (speedVal === 0.5) {\r\n    return \"Speed: Slow\";\r\n  } else if (speedVal === 1) {\r\n    return \"Speed: Normal\";\r\n  } else if (speedVal === 2) {\r\n    return \"Speed: Fast\";\r\n  } else {\r\n    return \"Speed: Rapid\";\r\n  }\r\n};\r\n\r\nconst getVisualizeButtonContent = (algorithmID, heuristicID) => {\r\n  if (algorithmID === null) {\r\n    return \"Select an Algorithm!\";\r\n  } else {\r\n    if (algorithmID === \"dijkstra\") {\r\n      return \"Visualize Dijkstra!\";\r\n    } else if (algorithmID === \"breadth\") {\r\n      return \"Visualize BFS!\";\r\n    } else if (algorithmID === \"bidirectional\") {\r\n      return \"Visualize Bidirectional BFS!\";\r\n    } else if (algorithmID === \"depth\") {\r\n      return \"Visualize DFS!\";\r\n    } else {\r\n      if (heuristicID === null) {\r\n        return \"Select a Heuristic!\";\r\n      } else {\r\n        if (algorithmID === \"a*\") {\r\n          return \"Visualize A* (\" + heuristicID + \") Search!\";\r\n        } else {\r\n          return \"Visualize Greedy (\" + heuristicID + \") Search!\";\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst getAnalyticsContent = (numVisited, totalCost) => {\r\n  if (numVisited === null) {\r\n    return \"Simulating...\";\r\n  } else {\r\n    return \"Nodes Explored: \" + numVisited + \" | Total Cost: \" + totalCost;\r\n  }\r\n};\r\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <>\n      <div className=\"App\">\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    </>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}